<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Mysite by sstd521</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Mysite</h1>
      <h2 class="project-tagline">集合</h2>
      <a href="https://github.com/sstd521/mysite" class="btn">View on GitHub</a>
      <a href="https://github.com/sstd521/mysite/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/sstd521/mysite/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="1-集合存对象的容器" class="anchor" href="#1-%E9%9B%86%E5%90%88%E5%AD%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E5%99%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1. 集合（存对象的容器）</h1>

<p>以下都为接口
<code>set</code> 无序不重复<br>
<code>hashset</code> 需要比较两个对象的<code>equals</code>和<code>hashcode</code>值都相同才会认为是重复，如何没有重写<code>equals</code>和<code>hashcode</code>方法，<code>new</code> 两个<code>equals</code>相同的对象，其<code>hashcode</code>不同，则为两个不同对象，而字符串默认已经重写了<code>equals</code>和<code>hashcode</code>方法
<code>TreeSet</code>会调用<code>compareTo</code>进行排序，字符串默认已经实现了<code>comparable</code>接口，first()等需要实现了compareTo方法，对象比较需要类实现<code>Comparable</code>接口，实现<code>compareTo</code>方法，<code>String</code>逆序，需要定义一个<code>String</code>排序器类，并将排序对象传入<code>new TreeSet&lt;&gt;(new StringComparator())</code> ，若无需比较功能，建议使用<code>hashset</code>,效率高
<code>public int compareTo(Apple obj) {</code>
<code>return this.weight &gt; obj.weight ? 1 : this.weight &lt; obj.weight ? -1 : 0; }</code>
<code>list</code>有序可重复
<code>arraylist</code> 相当于数组 顺序表 查找效率高
<code>linklist</code>（实现了deque 堆栈、队列）   相当于链表  增删改效率高
queue 以队列形式存对象 
map 映射关系的对象  键对象不能重复，若重复，新的键值对会覆盖旧的键值对</p>

<hr>

<p>2.遍历</p>

<p><code>Iterator&lt;String&gt; iterator = collection.iterator();</code>
<code>while (iterator.hasNext())</code>
<code>{   System.out.println(iterator.next())   }</code>
建议使用<code>foreach</code></p>

<p>PM
<code>HashMap</code>  若对象作为键，需要重写<code>equals</code>和<code>hashcode</code>方法，才能判断键值是否相等，若键值相同，则新键值对会覆盖旧键值对
<code>TreeMap</code>同TreeSet会调用compareTo进行排序,需要类实现Comparable接口，实现<code>compareTo</code>方法
<code>map.remove("键")</code>  返回键对应的值 <code>map.remove("键"，"value")</code>  返回<code>boolean</code></p>

<p><code>TreeMap</code>要求<code>key</code>必须是可比较大小的。</p>

<ul>
<li>a）自然排序：要求所有的key实现<code>Comparable</code>接口；</li>
<li>b）定制排序：要求创建<em>TreeMap</em>时提供一个<code>Comparator</code>接口。
<code>TreeMap</code>怎样才算两个key重复？</li>
<li>a）通过<code>compareTo()</code>比较大小时返回0，就表明两个元素相等</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/sstd521/mysite">Mysite</a> is maintained by <a href="https://github.com/sstd521">sstd521</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
