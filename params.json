{
  "name": "Mysite",
  "tagline": "集合",
  "body": "# 1. 集合（存对象的容器）\r\n\r\n以下都为接口\r\n`set` 无序不重复   \r\n`hashset` 需要比较两个对象的`equals`和`hashcode`值都相同才会认为是重复，如何没有重写`equals`和`hashcode`方法，`new` 两个`equals`相同的对象，其`hashcode`不同，则为两个不同对象，而字符串默认已经重写了`equals`和`hashcode`方法\r\n`TreeSet `会调用`compareTo`进行排序，字符串默认已经实现了`comparable`接口，first()等需要实现了compareTo方法，对象比较需要类实现`Comparable`接口，实现`compareTo`方法，`String`逆序，需要定义一个`String`排序器类，并将排序对象传入`new TreeSet<>(new StringComparator())` ，若无需比较功能，建议使用`hashset`,效率高\r\n`public int compareTo(Apple obj) {`\r\n`return this.weight > obj.weight ? 1 : this.weight < obj.weight ? -1 : 0; }`\r\n`list `有序可重复\r\n`arraylist ` 相当于数组 顺序表 查找效率高\r\n`linklist `（实现了deque 堆栈、队列）   相当于链表  增删改效率高\r\nqueue 以队列形式存对象 \r\nmap 映射关系的对象  键对象不能重复，若重复，新的键值对会覆盖旧的键值对\r\n\r\n***\r\n\r\n2.遍历\r\n\r\n`Iterator<String> iterator = collection.iterator();`\r\n`while (iterator.hasNext())`\r\n`{   System.out.println(iterator.next())   }`\r\n建议使用`foreach`\r\n\r\nPM\r\n`HashMap`  若对象作为键，需要重写`equals`和`hashcode`方法，才能判断键值是否相等，若键值相同，则新键值对会覆盖旧键值对\r\n`TreeMap `同TreeSet会调用compareTo进行排序,需要类实现Comparable接口，实现`compareTo`方法\r\n`map.remove(\"键\")`  返回键对应的值 ` map.remove(\"键\"，\"value\")`  返回`boolean`\r\n\r\n`TreeMap`要求`key`必须是可比较大小的。\r\n* a）自然排序：要求所有的key实现`Comparable`接口；\r\n* b）定制排序：要求创建_TreeMap_时提供一个`Comparator`接口。\r\n`TreeMap`怎样才算两个key重复？\r\n* a）通过`compareTo()`比较大小时返回0，就表明两个元素相等",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}